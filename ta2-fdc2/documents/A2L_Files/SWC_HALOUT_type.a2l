/******************************************************************************
 *
 *  ASAP2 file:     SWC_HALOUT_type.a2l
 *
 * Code generation for model "SWC_HALOUT_type".
 *
 * Model version              : 1.10
 * Simulink Coder version : 9.6 (R2021b) 14-May-2021
 * C source code generated on : Tue May 13 16:41:01 2025
 * 
 * Target selection: autosar.tlc
 * Embedded hardware selection: ARM Compatible->ARM Cortex-M
 * Code generation objectives: Unspecified
 * Validation result: Not run
 *
 * (add additional file header information here)
 *
 ******************************************************************************/

ASAP2_VERSION  1 31   /* Version 1.31 */

/begin PROJECT ProjectName "Project Comment Goes Here"
  
  /begin HEADER "Header Comments go here"
    
  /end HEADER
  
  
  /begin MODULE ModuleName  "Module Comment Goes Here"
    /begin A2ML 
      
      /* **************************************************************************************** */
      
      /****************************************************************************/
      /*                                                                          */
      /*   ASAP2 meta language for XCP protocol V1.0                              */
      /*                                                                          */
      /*   AML v1.0, 10.18.2002                                                   */
      /*                                                                          */
      /*   Vector Informatik, Schuermans                                          */
      /*                                                                          */
      /*   Datatypes:                                                             */
      /*                                                                          */
      /*   A2ML       ASAP2          Windows  description                         */
      /*   ----------------------------------------------------------------       */
      /*   uchar      UBYTE          BYTE     unsigned 8 Bit                      */
      /*   char       SBYTE          char     signed 8 Bit                        */
      /*   uint       UWORD          WORD     unsigned integer 16 Bit             */
      /*   int        SWORD          int      signed integer 16 Bit               */
      /*   ulong      ULONG          DWORD    unsigned integer 32 Bit             */
      /*   long       SLONG          LONG     signed integer 32 Bit               */
      /*   float      FLOAT32_IEEE            float 32 Bit                        */
      /*                                                                          */
      /****************************************************************************/
      
      /************************ start of XCP definitions **************************/
      
      /* Part 2 protocol layer part     */
      /************************************************************************************/ 
      /*                                                                                  */ 
      /*   ASAP2 meta language for XCP protocol layer V1.0                                */ 
      /*                                                                                  */ 
      /*   2003-03-03                                                                     */ 
      /*                                                                                  */ 
      /*   Vector Informatik, Schuermans                                                  */ 
      /*                                                                                  */ 
      /*   Datatypes:                                                                     */ 
      /*                                                                                  */ 
      /*   A2ML       ASAP2             Windows      description                          */ 
      /*   -------------------------------------------------------------------------------*/ 
      /*   uchar      UBYTE             BYTE         unsigned 8 Bit                       */ 
      /*   char       SBYTE             char         signed 8 Bit                         */ 
      /*   uint       UWORD             WORD         unsigned integer 16 Bit              */ 
      /*   int        SWORD             int          signed integer 16 Bit                */ 
      /*   ulong      ULONG             DWORD        unsigned integer 32 Bit              */ 
      /*   long       SLONG             LONG         signed integer 32 Bit                */ 
      /*   float      FLOAT32_IEEE                   float 32 Bit                         */ 
      /*                                                                                  */ 
      /************************************************************************************/ 
      /*********************** start of PROTOCOL_LAYER ****************************/ 
      
      struct Protocol_Layer {     /* At MODULE */ 
      
      uint;                                /* XCP protocol layer version */ 
      /* e.g. "1.0" = 0x0100            */ 
      
      uint;                                /* T1 [ms] */ 
      uint;                                /* T2 [ms] */ 
      uint;                                /* T3 [ms] */ 
      uint;                                /* T4 [ms] */ 
      uint;                                /* T5 [ms] */ 
      uint;                                /* T6 [ms] */ 
      uint;                                /* T7 [ms] */ 
      
      uchar;                               /* MAX_CTO */ 
      uint;                                /* MAX_DTO */ 
      
      enum {                               /* BYTE_ORDER */ 
      "BYTE_ORDER_MSB_LAST"  = 0, 
      "BYTE_ORDER_MSB_FIRST" = 1 
      }; 
      
      enum {                               /* ADDRESS_GRANULARITY */ 
      "ADDRESS_GRANULARITY_BYTE"    = 1, 
      "ADDRESS_GRANULARITY_WORD"    = 2, 
      "ADDRESS_GRANULARITY_DWORD"   = 4 
      }; 
      
      taggedstruct {                       /* optional                     */ 
      
      ("OPTIONAL_CMD" enum {             /* XCP-Code of optional command */  
      /* supported by the slave       */ 
      
      "GET_COMM_MODE_INFO"       = 0xFB, 
      "GET_ID"                   = 0xFA, 
      "SET_REQUEST"              = 0xF9, 
      "GET_SEED"                 = 0xF8, 
      "UNLOCK"                   = 0xF7, 
      "SET_MTA"                  = 0xF6, 
      "UPLOAD"                   = 0xF5, 
      "SHORT_UPLOAD"             = 0xF4, 
      "BUILD_CHECKSUM"           = 0xF3, 
      "TRANSPORT_LAYER_CMD"      = 0xF2, 
      "USER_CMD"                 = 0xF1, 
      "DOWNLOAD"                 = 0xF0, 
      "DOWNLOAD_NEXT"            = 0xEF, 
      "DOWNLOAD_MAX"             = 0xEE, 
      "SHORT_DOWNLOAD"           = 0xED, 
      "MODIFY_BITS"              = 0xEC, 
      "SET_CAL_PAGE"             = 0xEB, 
      "GET_CAL_PAGE"             = 0xEA, 
      "GET_PAG_PROCESSOR_INFO"   = 0xE9, 
      "GET_SEGMENT_INFO"         = 0xE8, 
      "GET_PAGE_INFO"            = 0xE7, 
      "SET_SEGMENT_MODE"         = 0xE6, 
      "GET_SEGMENT_MODE"         = 0xE5, 
      "COPY_CAL_PAGE"            = 0xE4, 
      "CLEAR_DAQ_LIST"           = 0xE3, 
      "SET_DAQ_PTR"              = 0xE2, 
      "WRITE_DAQ"                = 0xE1, 
      "SET_DAQ_LIST_MODE"        = 0xE0, 
      "GET_DAQ_LIST_MODE"        = 0xDF, 
      "START_STOP_DAQ_LIST"      = 0xDE, 
      "START_STOP_SYNCH"         = 0xDD, 
      "GET_DAQ_CLOCK"            = 0xDC, 
      "READ_DAQ"                 = 0xDB, 
      "GET_DAQ_PROCESSOR_INFO"   = 0xDA, 
      "GET_DAQ_RESOLUTION_INFO"  = 0xD9, 
      "GET_DAQ_LIST_INFO"        = 0xD8, 
      "GET_DAQ_EVENT_INFO"       = 0xD7, 
      "FREE_DAQ"                 = 0xD6, 
      "ALLOC_DAQ"                = 0xD5, 
      "ALLOC_ODT"                = 0xD4, 
      "ALLOC_ODT_ENTRY"          = 0xD3, 
      "PROGRAM_START"            = 0xD2, 
      "PROGRAM_CLEAR"            = 0xD1, 
      "PROGRAM"                  = 0xD0, 
      "PROGRAM_RESET"            = 0xCF, 
      "GET_PGM_PROCESSOR_INFO"   = 0xCE, 
      "GET_SECTOR_INFO"          = 0xCD, 
      "PROGRAM_PREPARE"          = 0xCC, 
      "PROGRAM_FORMAT"           = 0xCB, 
      "PROGRAM_NEXT"             = 0xCA, 
      "PROGRAM_MAX"              = 0xC9, 
      "PROGRAM_VERIFY"           = 0xC8 
      
      })*;           
      
      "COMMUNICATION_MODE_SUPPORTED" taggedunion { /* optional modes supported */ 
      "BLOCK" taggedstruct { 
      "SLAVE";                  /* Slave Block Mode supported  */ 
      "MASTER" struct {         /* Master Block Mode supported */ 
      uchar;  /* MAX_BS */ 
      uchar;  /* MIN_ST */ 
      }; 
      }; 
      "INTERLEAVED" uchar;    /* QUEUE_SIZE */  
      }; 
      
      "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function */ 
      /* including file extension      */ 
      /* without path                  */ 
      }; 
      
      }; /********************* end of PROTOCOL_LAYER *****************************/ 
      
      /***************************** start of DAQ *********************************/ 
      struct Daq {                         /* DAQ supported, at MODULE*/ 
      enum {                             /* DAQ_CONFIG_TYPE */ 
      "STATIC"  = 0, 
      "DYNAMIC" = 1 
      }; 
      
      uint;                               /* MAX_DAQ */ 
      uint;                               /* MAX_EVENT_CHANNEL */ 
      uchar;                              /* MIN_DAQ */ 
      
      enum {                            /* OPTIMISATION_TYPE */ 
      "OPTIMISATION_TYPE_DEFAULT"            = 0, 
      "OPTIMISATION_TYPE_ODT_TYPE_16"        = 1, 
      "OPTIMISATION_TYPE_ODT_TYPE_32"        = 2, 
      "OPTIMISATION_TYPE_ODT_TYPE_64"        = 3, 
      "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4, 
      "OPTIMISATION_TYPE_MAX_ENTRY_SIZE"     = 5 
      }; 
      
      enum {                           /* ADDRESS_EXTENSION */ 
      "ADDRESS_EXTENSION_FREE" = 0, 
      "ADDRESS_EXTENSION_ODT"  = 1, 
      "ADDRESS_EXTENSION_DAQ"  = 3 
      }; 
      
      
      enum {                           /* IDENTIFICATION_FIELD */ 
      "IDENTIFICATION_FIELD_TYPE_ABSOLUTE"              = 0, 
      "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE"         = 1, 
      "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD"         = 2, 
      "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3 
      }; 
      
      
      enum {                        /* GRANULARITY_ODT_ENTRY_SIZE_DAQ */ 
      "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE"    = 1, 
      "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD"    = 2, 
      "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD"   = 4, 
      "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG"   = 8 
      }; 
      
      uchar;                              /* MAX_ODT_ENTRY_SIZE_DAQ */ 
      
      enum {                              /* OVERLOAD_INDICATION */ 
      "NO_OVERLOAD_INDICATION"    = 0, 
      "OVERLOAD_INDICATION_PID"   = 1, 
      "OVERLOAD_INDICATION_EVENT" = 2 
      }; 
      
      taggedstruct {                      /* optional */ 
      "PRESCALER_SUPPORTED"; 
      "RESUME_SUPPORTED"; 
      
      block "STIM" struct {             /* STIM supported */ 
      
      enum {                      /* GRANULARITY_ODT_ENTRY_SIZE_STIM */ 
      "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE"   = 1, 
      "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD"   = 2, 
      "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD"  = 4, 
      "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG"  = 8 
      }; 
      
      uchar;                          /* MAX_ODT_ENTRY_SIZE_STIM */ 
      
      taggedstruct {                  /* bitwise stimulation */ 
      "BIT_STIM_SUPPORTED"; 
      }; 
      }; 
      
      block "TIMESTAMP_SUPPORTED" struct {  
      uint;                           /* TIMESTAMP_TICKS */ 
      enum { /* TIMESTAMP_SIZE */ 
      "NO_TIME_STAMP" = 0, 
      "SIZE_BYTE"     = 1, 
      "SIZE_WORD"     = 2, 
      "SIZE_DWORD"    = 4 
      }; 
      enum { /* RESOLUTION OF TIMESTAMP */ 
      "UNIT_1NS"   = 0, 
      "UNIT_10NS"  = 1, 
      "UNIT_100NS" = 2, 
      "UNIT_1US"   = 3, 
      "UNIT_10US"  = 4, 
      "UNIT_100US" = 5, 
      "UNIT_1MS"   = 6, 
      "UNIT_10MS"  = 7, 
      "UNIT_100MS" = 8, 
      "UNIT_1S"    = 9 
      }; 
      taggedstruct { 
      "TIMESTAMP_FIXED"; 
      }; 
      }; 
      
      "PID_OFF_SUPPORTED"; 
      
      /************************ start of DAQ_LIST *************************/ 
      
      (block "DAQ_LIST" struct {          /* DAQ_LIST                    */ 
      /* multiple possible           */ 
      uint;                             /* DAQ_LIST_NUMBER             */ 
      taggedstruct {                            /* optional */ 
      "DAQ_LIST_TYPE" enum {               
      "DAQ"      = 1,               /* DIRECTION = DAQ only     */ 
      "STIM"     = 2,               /* DIRECTION = STIM only    */ 
      "DAQ_STIM" = 3                /* both directions possible */ 
      /* but not simultaneously   */ 
      }; 
      
      "MAX_ODT"         uchar;        /* MAX_ODT         */ 
      "MAX_ODT_ENTRIES" uchar;        /* MAX_ODT_ENTRIES */ 
      
      "FIRST_PID" uchar;              /* FIRST_PID for this DAQ_LIST */ 
      "EVENT_FIXED" uint;             /* this DAQ_LIST always        */ 
      /* in this event               */ 
      block "PREDEFINED" taggedstruct { /* predefined                */ 
      /* not configurable DAQ_LIST */ 
      (block "ODT" struct { 
      uchar;                   /* ODT number */ 
      taggedstruct { 
      ("ODT_ENTRY" struct { 
      uchar;   /* ODT_ENTRY number            */ 
      ulong;   /* address of element                 */ 
      uchar;   /* address extension of element */ 
      uchar;   /* size of element [AG]                */ 
      uchar;   /* BIT_OFFSET                          */ 
      })*; 
      }; /* end of ODT_ENTRY */ 
      })*; /* end of ODT */ 
      }; /* end of PREDEFINED */ 
      }; 
      })*;/********************* end of DAQ_LIST ***************************/ 
      
      /************************* start of EVENT ****************************/ 
      
      (block "EVENT" struct {             /* EVENT               */ 
      /* multiple possible   */ 
      char[101];                        /* EVENT_CHANNEL_NAME       */ 
      char[9];                          /* EVENT_CHANNEL_SHORT_NAME */ 
      uint;                             /* EVENT_CHANNEL_NUMBER     */ 
      
      enum { 
      "DAQ"      = 1,                 /* only DAQ_LISTs         */ 
      /* with DIRECTION = DAQ   */ 
      "STIM"     = 2,                 /* only DAQ_LISTs         */ 
      /* with DIRECTION = STIM  */ 
      "DAQ_STIM" = 3                  /* both kind of DAQ_LISTs */ 
      }; 
      
      uchar;                            /* MAX_DAQ_LIST */ 
      uchar;                            /* TIME_CYCLE   */ 
      uchar;                            /* TIME_UNIT    */ 
      uchar;                            /* PRIORITY     */ 
      
      })*;/******************** end of EVENT ********************************/ 
      
      }; /* end of optional at DAQ */ 
      
      }; /************************* end of DAQ *************************************/ 
      
      
      /**************************** start of DAQ_EVENT *****************************/ 
      
      taggedunion Daq_Event {         /* at MEASUREMENT */ 
      "FIXED_EVENT_LIST" taggedstruct { 
      ("EVENT" uint)* ; 
      }; 
      "VARIABLE" taggedstruct { 
      block "AVAILABLE_EVENT_LIST" taggedstruct { 
      ("EVENT" uint)*; 
      }; 
      block "DEFAULT_EVENT_LIST" taggedstruct { 
      ("EVENT" uint)*; 
      }; 
      }; 
      }; /************************* end of DAQ_EVENT *******************************/ 
      
      
      /**************************** start of PAG ***********************************/ 
      
      struct Pag {                  /* PAG supported, at MODULE */ 
      uchar;                      /* MAX_SEGMENTS */ 
      taggedstruct {              /* optional */ 
      "FREEZE_SUPPORTED"; 
      }; 
      
      }; /************************* end of PAG *************************************/ 
      
      
      /**************************** start of PGM ***********************************/ 
      
      struct Pgm {                  /* PGM supported, at MODULE */ 
      
      enum { 
      "PGM_MODE_ABSOLUTE"                = 1, 
      "PGM_MODE_FUNCTIONAL"              = 2, 
      "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3 
      }; 
      uchar;                               /* MAX_SECTORS */ 
      uchar;                               /* MAX_CTO_PGM */ 
      
      taggedstruct {                       /* optional                */ 
      (block "SECTOR" struct {           /* SECTOR                  */ 
      /* multiple possible       */ 
      char[101];                       /* SECTOR_NAME             */ 
      uchar;                           /* SECTOR_NUMBER           */ 
      ulong;                           /* Address                 */ 
      ulong;                           /* Length                  */ 
      uchar;                           /* CLEAR_SEQUENCE_NUMBER   */ 
      uchar;                           /* PROGRAM_SEQUENCE_NUMBER */ 
      uchar;                           /* PROGRAM_METHOD          */ 
      })*; /* end of SECTOR */ 
      
      "COMMUNICATION_MODE_SUPPORTED" taggedunion { /* optional modes supported */ 
      "BLOCK" taggedstruct { 
      "SLAVE";                  /* Slave Block Mode supported  */ 
      "MASTER" struct {         /* Master Block Mode supported */ 
      uchar;  /* MAX_BS_PGM */ 
      uchar;  /* MIN_ST_PGM */ 
      }; 
      }; 
      "INTERLEAVED" uchar;    /* QUEUE_SIZE_PGM */  
      }; 
      }; 
      }; /************************** end of PGM *************************************/ 
      
      
      /***************************** start of SEGMENT *******************************/ 
      
      struct Segment {               /* at MEMORY_SEGMENT */ 
      uchar;                               /* SEGMENT_NUMBER     */ 
      uchar;                               /* number of pages    */ 
      uchar;                               /* ADDRESS_EXTENSION  */ 
      uchar;                               /* COMPRESSION_METHOD */ 
      uchar;                               /* ENCRYPTION_METHOD  */ 
      
      taggedstruct {                       /* optional           */ 
      block "CHECKSUM" struct { 
      enum {                           /* checksum type      */ 
      "XCP_ADD_11"       =   1, 
      "XCP_ADD_12"       =   2, 
      "XCP_ADD_14"       =   3, 
      "XCP_ADD_22"       =   4, 
      "XCP_ADD_24"       =   5, 
      "XCP_ADD_44"       =   6, 
      "XCP_CRC_16"       =   7, 
      "XCP_CRC_16_CITT"  =   8, 
      "XCP_CRC_32"       =   9, 
      "XCP_USER_DEFINED" = 255 
      }; 
      
      taggedstruct { 
      "MAX_BLOCK_SIZE"              ulong ;    /* maximum block size            */ 
      /* for checksum calculation      */ 
      "EXTERNAL_FUNCTION" char[256];           /* Name of the Checksum function */ 
      /* including file extension      */ 
      /* without path                  */ 
      }; 
      }; 
      
      (block "PAGE" struct {               /* PAGES for this SEGMENT */ 
      /* multiple possible      */ 
      uchar;                             /* PAGE_NUMBER            */ 
      
      enum {            /* ECU_ACCESS_TYPE */ 
      "ECU_ACCESS_NOT_ALLOWED"      = 0, 
      "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1, 
      "ECU_ACCESS_WITH_XCP_ONLY"    = 2, 
      "ECU_ACCESS_DONT_CARE"        = 3 
      }; 
      
      enum {       /* XCP_READ_ACCESS_TYPE */ 
      "XCP_READ_ACCESS_NOT_ALLOWED"      = 0, 
      "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1, 
      "XCP_READ_ACCESS_WITH_ECU_ONLY"    = 2, 
      "XCP_READ_ACCESS_DONT_CARE"        = 3 
      }; 
      
      enum {      /* XCP_WRITE_ACCESS_TYPE */ 
      "XCP_WRITE_ACCESS_NOT_ALLOWED"      = 0, 
      "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1, 
      "XCP_WRITE_ACCESS_WITH_ECU_ONLY"    = 2, 
      "XCP_WRITE_ACCESS_DONT_CARE"        = 3 
      }; 
      taggedstruct { 
      "INIT_SEGMENT" uchar; /* references segment that initialises this page */ 
      }; 
      
      })*; /* end of PAGE */                 
      
      (block "ADDRESS_MAPPING" struct {  /* multiple possible   */ 
      ulong;        /* source address      */ 
      ulong;        /* destination address */ 
      ulong;        /* length              */ 
      })*; 
      
      "PGM_VERIFY" ulong; /* verification value for PGM */ 
      }; /* end of optional */ 
      
      }; /************************** end of SEGMENT *********************************/ 
      
      /*********************** start of Common Parameters ***************************/ 
      
      taggedstruct Common_Parameters {  
      
      block "PROTOCOL_LAYER" struct Protocol_Layer; 
      
      block "SEGMENT" struct Segment; 
      
      block "DAQ" struct Daq; 
      block "PAG" struct Pag; 
      block "PGM" struct Pgm; 
      
      block "DAQ_EVENT" taggedunion Daq_Event; 
      
      }; /******************** end of Common Parameters *****************************/ 
      
      /* Part 3 transport layer part    */
      /************************************************************************************/
      /*                                                                                  */
      /* ASAP2 meta language for XCP on CAN V1.0                                          */
      /*                                                                                  */
      /* 2003-03-03                                                                       */
      /*                                                                                  */
      /* Vector Informatik, Schuermans                                                    */
      /*                                                                                  */
      /* Datatypes:                                                                       */
      /*                                                                                  */
      /* A2ML ASAP2 Windows description                                                   */
      /* ---------------------------------------------------------------------------------*/
      /* uchar UBYTE BYTE unsigned 8 Bit                                                  */
      /* char SBYTE char signed 8 Bit                                                     */
      /* uint UWORD WORD unsigned integer 16 Bit                                          */
      /* int SWORD int signed integer 16 Bit                                              */
      /* ulong ULONG DWORD unsigned integer 32 Bit                                        */
      /* long SLONG LONG signed integer 32 Bit                                            */
      /* float FLOAT32_IEEE float 32 Bit                                                  */
      /*                                                                                  */
      /************************************************************************************/
      /************************ start of CAN **********************************************/
      struct CAN_Parameters { /* At MODULE */
      uint; /* XCP on CAN version */
      /* e.g. "1.0" = 0x0100 */
      taggedstruct { /* optional */
      "CAN_ID_BROADCAST" ulong; /* Auto detection CAN-ID */
      /* master -> slaves */
      /* Bit31= 1: extended identifier */
      "CAN_ID_MASTER" ulong;    /* CMD/STIM CAN-ID */
      /* master -> slave */
      /* Bit31= 1: extended identifier */
      "CAN_ID_SLAVE" ulong;     /* RES/ERR/EV/SERV/DAQ CAN-ID */
      /* slave -> master */
      /* Bit31= 1: extended identifier */
      "BAUDRATE" ulong;         /* BAUDRATE [Hz] */
      "SAMPLE_POINT" uchar;     /* sample point */
      /* [% complete bit time] */
      "SAMPLE_RATE" enum {
      "SINGLE" = 1,           /* 1 sample per bit */
      "TRIPLE" = 3            /* 3 samples per bit */
      };
      "BTL_CYCLES" uchar;       /* BTL_CYCLES */
      /* [slots per bit time] */
      "SJW" uchar;              /* length synchr. segment */
      /* [BTL_CYCLES] */
      "SYNC_EDGE" enum {
      "SINGLE" = 1,           /* on falling edge only */
      "DUAL" = 2              /* on falling and rising edge */
      };
      "MAX_DLC_REQUIRED";       /* master to slave frames */
      /* always to have DLC = MAX_DLC = 8 */
      (block "DAQ_LIST_CAN_ID" struct { /* At IF_DATA DAQ */
      uint;                   /* reference to DAQ_LIST_NUMBER */
      taggedstruct {          /* exclusive tags */
      /* either VARIABLE or FIXED */
      "VARIABLE";
      "FIXED" ulong;        /* this DAQ_LIST always */
      /* on this CAN_ID */
      };
      })*;
      };
      };/************************* end of CAN ***********************************/
      /************************** start of SxI ************************************/
      struct SxI_Parameters { /* At MODULE */
      uint;  /* XCP on SxI version */
      /* e.g. "1.0" = 0x0100 */
      ulong; /* BAUDRATE [Hz] */
      taggedstruct { /* exclusive tags */
      "ASYNCH_FULL_DUPLEX_MODE" struct {
      enum {
      "PARITY_NONE" = 0,
      "PARITY_ODD" = 1,
      "PARITY_EVEN" = 2
      };
      enum {
      "ONE_STOP_BIT" = 1,
      "TWO_STOP_BITS" = 2
      };
      };
      "SYNCH_FULL_DUPLEX_MODE_BYTE";
      "SYNCH_FULL_DUPLEX_MODE_WORD";
      "SYNCH_FULL_DUPLEX_MODE_DWORD";
      "SYNCH_MASTER_SLAVE_MODE_BYTE";
      "SYNCH_MASTER_SLAVE_MODE_WORD";
      "SYNCH_MASTER_SLAVE_MODE_DWORD";
      };
      enum {
      "HEADER_LEN_BYTE" = 0,
      "HEADER_LEN_CTR_BYTE" = 1,
      "HEADER_LEN_FILL_BYTE" = 2,
      "HEADER_LEN_WORD" = 3,
      "HEADER_LEN_CTR_WORD" = 4,
      "HEADER_LEN_FILL_WORD" = 5
      };
      enum {
      "NO_CHECKSUM" = 0,
      "CHECKSUM_BYTE" = 1,
      "CHECKSUM_WORD" = 2
      };
      };/*************************** end of SxI ***********************************/
      
      /************************ start of TCP_IP ***********************************/
      
      struct TCP_IP_Parameters {
      
      uint; /* XCP on UDP_IP version */
      /* e.g. "1.0" = 0x0100 */
      uint; /* PORT */
      
      taggedunion {
      "HOST_NAME" char[256];
      "ADDRESS" char[15];
      };
      
      };/************************* end of TCP_IP ***********************************/
      
      /************************** start of UDP ************************************/
      
      struct UDP_IP_Parameters {
      uint; /* XCP on UDP_IP version */
      /* e.g. "1.0" = 0x0100 */
      uint; /* PORT */
      
      taggedunion {
      "HOST_NAME" char[256];
      "ADDRESS" char[15];
      };
      
      };/*************************** end of UDP ***********************************/
      
      /****************************************************************************/
      /*                                                                          */
      /* ASAP2 meta language for XCP protocol V1.0                                */
      /*                                                                          */
      /****************************************************************************/
      /************************ start of USB **************************************/
      struct ep_parameters {
      uchar;                    /* ENDPOINT_NUMBER, not endpoint address */
      enum {
      "BULK_TRANSFER"      = 2,          /* Numbers according to USB spec. */
      "INTERRUPT_TRANSFER" = 3
      };
      uint;                              /* wMaxPacketSize: Maximum packet */
      /* size of endpoint in bytes */
      uchar;                             /* bInterval: polling of endpoint */
      enum {                             /* Packing of XCP Messages */
      "MESSAGE_PACKING_SINGLE"    = 0, /* Single per USB data packet */
      "MESSAGE_PACKING_MULTIPLE"  = 1, /* Multiple per USB data packet */
      "MESSAGE_PACKING_STREAMING" = 2  /* No restriction by packet sizes */
      };
      enum {                             /* Alignment mandatory for all */
      "ALIGNMENT_8_BIT" = 0,           /* packing types */
      "ALIGNMENT_16_BIT"= 1,
      "ALIGNMENT_32_BIT"= 2,
      "ALIGNMENT_64_BIT"= 3
      };
      taggedstruct {                     /* Optional */
      "RECOMMENDED_HOST_BUFSIZE" uint; /* Recommended size for the host */
      /* buffer size. The size is defined*/
      /* as multiple of wMaxPacketSize. */
      };
      }; /* end of ep_parameters */
      
      struct USB_Parameters {
      uint;                              /* XCP on USB version */
      /* e.g. 1.0 = 0x0100 */
      uint;                              /* Vendor ID */
      uint;                              /* Product ID */
      uchar;                             /* Number of interface */
      enum {
      "HEADER_LEN_BYTE"      = 0,
      "HEADER_LEN_CTR_BYTE"  = 1,
      "HEADER_LEN_FILL_BYTE"  = 2,
      "HEADER_LEN_WORD"      = 3,
      "HEADER_LEN_CTR_WORD"  = 4,
      "HEADER_LEN_FILL_WORD" = 5
      };
      taggedunion {                      /* OUT-EP for CMD and */
      /* STIM (if not specified otherwise) */
      block "OUT_EP_CMD_STIM" struct ep_parameters;
      };
      taggedunion {                      /* IN-EP for RES/ERR, */
      /* DAQ (if not specified otherwise) and */
      /* EV/SERV (if not specified otherwise) */
      block "IN_EP_RESERR_DAQ_EVSERV" struct ep_parameters;
      };
      /* ----------- Begin of optional ------- */
      taggedstruct { /* Optional */
      "ALTERNATE_SETTING_NO" uchar;    /* Number of alternate setting */
      /* String Descriptor of XCP */
      /* interface */
      "INTERFACE_STRING_DESCRIPTOR" char [101];
      /* multiple OUT-EP's for STIM */
      (block "OUT_EP_ONLY_STIM" struct ep_parameters)*;
      /* multiple IN-EP's for DAQ */
      (block "IN_EP_ONLY_DAQ" struct ep_parameters)*;
      /* only one IN-EP for EV/SERV */
      block "IN_EP_ONLY_EVSERV" struct ep_parameters;
      (block "DAQ_LIST_USB_ENDPOINT" struct {
      uint;                          /* reference to DAQ_LIST_NUMBER */
      taggedstruct {                 /* only mentioned if not VARIABLE */
      "FIXED_IN" uchar;            /* this DAQ list always */
      /* ENDPOINT_NUMBER, not endpoint address */
      "FIXED_OUT" uchar;           /* this STIM list always */
      /* ENDPOINT_NUMBER, not endpoint address */
      };
      })*; /* end of DAQ_LIST_USB_ENDPOINT */
      }; /* end of optional */
      };/************************* end of USB ***********************************/
      
      /************************ end of XCP definitions ****************************/
      
      
      block "IF_DATA" taggedunion if_data {
      
      /************* start of XCP on different Transport Layers *******************/
      
      "XCP" struct {
      
      taggedstruct Common_Parameters ; /* default parameters */
      
      taggedstruct { /* transport layer specific parameters  */
      /* overruling of the default parameters */
      
      block "XCP_ON_CAN" struct {
      
      struct CAN_Parameters ;                   /* specific for CAN      */
      taggedstruct Common_Parameters;           /* overruling of default */
      
      };
      
      block "XCP_ON_SxI" struct {
      
      struct SxI_Parameters ;                   /* specific for SPI      */
      taggedstruct Common_Parameters;           /* overruling of default */
      
      };
      
      block "XCP_ON_TCP_IP" struct {
      
      struct TCP_IP_Parameters ;                /* specific for TCP_IP   */
      taggedstruct Common_Parameters;           /* overruling of default */
      
      };
      
      block "XCP_ON_UDP_IP" struct {
      
      struct UDP_IP_Parameters ;                /* specific for UDP      */
      taggedstruct Common_Parameters;           /* overruling of default */
      
      };
      
      block "XCP_ON_USB" struct {
      
      struct USB_Parameters ;                   /* specific for USB      */
      taggedstruct Common_Parameters;           /* overruling of default */
      
      };
      
      };
      
      };/************* end of XCP on different Transport Layers ********************/
      
      };
      
      /* **************************************************************************************** */
      
    /end A2ML 
    
    /* **************************************************************************************** */
    
    /begin MOD_COMMON  "Mod Common Comment Here" 
      BYTE_ORDER     MSB_LAST
      ALIGNMENT_BYTE 1 
      ALIGNMENT_WORD 2 
      ALIGNMENT_LONG 2 
      ALIGNMENT_FLOAT32_IEEE 2 
      ALIGNMENT_FLOAT64_IEEE 4 
    /end MOD_COMMON 
    
    /* **************************************************************************************** */
    
    
    
    /begin IF_DATA XCP
      /begin PROTOCOL_LAYER
        /begin PROTOCOL_LAYER
          0x0100    /* XCP protocol layer version 1.0 */
          2000    /* T1 [ms] */
          2000    /* T2 [ms] */
          2000    /* T3 [ms] */
          2000    /* T4 [ms] */
          2000    /* T5 [ms] */
          0005    /* T6 [ms] */
          0005    /* T7 [ms] */
          0x08      /* MAX_CTO */
          0x0008    /* MAX_DTO */
          BYTE_ORDER_MSB_LAST
          ADDRESS_GRANULARITY_BYTE
          
          /*			SEED_AND_KEY_EXTERNAL_FUNCTION "stm32f1_seed_key.dll"	*/
          
          OPTIONAL_CMD GET_COMM_MODE_INFO
          OPTIONAL_CMD GET_ID
          OPTIONAL_CMD SET_REQUEST
          OPTIONAL_CMD GET_SEED
          OPTIONAL_CMD UNLOCK
          OPTIONAL_CMD SET_MTA
          OPTIONAL_CMD UPLOAD
          OPTIONAL_CMD SHORT_UPLOAD
          OPTIONAL_CMD BUILD_CHECKSUM
          OPTIONAL_CMD TRANSPORT_LAYER_CMD
          OPTIONAL_CMD USER_CMD
          OPTIONAL_CMD DOWNLOAD
          OPTIONAL_CMD DOWNLOAD_NEXT
          OPTIONAL_CMD SET_CAL_PAGE
          OPTIONAL_CMD GET_CAL_PAGE
          OPTIONAL_CMD GET_PAG_PROCESSOR_INFO
          OPTIONAL_CMD SET_DAQ_PTR
          OPTIONAL_CMD WRITE_DAQ
          OPTIONAL_CMD SET_DAQ_LIST_MODE
          OPTIONAL_CMD GET_DAQ_LIST_MODE
          OPTIONAL_CMD START_STOP_DAQ_LIST
          OPTIONAL_CMD START_STOP_SYNCH
          OPTIONAL_CMD GET_DAQ_CLOCK
          OPTIONAL_CMD READ_DAQ
          OPTIONAL_CMD GET_DAQ_PROCESSOR_INFO
          OPTIONAL_CMD GET_DAQ_RESOLUTION_INFO
          OPTIONAL_CMD GET_DAQ_LIST_INFO
          OPTIONAL_CMD GET_DAQ_EVENT_INFO
          OPTIONAL_CMD FREE_DAQ
          OPTIONAL_CMD ALLOC_DAQ
          OPTIONAL_CMD ALLOC_ODT
          OPTIONAL_CMD ALLOC_ODT_ENTRY
          OPTIONAL_CMD PROGRAM_START
          OPTIONAL_CMD PROGRAM
          OPTIONAL_CMD PROGRAM_CLEAR
          OPTIONAL_CMD PROGRAM_RESET
          OPTIONAL_CMD PROGRAM_NEXT
          OPTIONAL_CMD COPY_CAL_PAGE
          OPTIONAL_CMD MODIFY_BITS
          
          /begin COMMUNICATION_MODE_SUPPORTED
            /begin BLOCK
              SLAVE
              MASTER
              0xff
              100
            /end BLOCK
          /end COMMUNICATION_MODE_SUPPORTED
        /end PROTOCOL_LAYER
        /begin DAQ
          STATIC                                 /* DAQ_CONFIG_TYPE */
          0x03                                   /* MAX_DAQ */
          0x03                                   /* MAX_EVENT_CHANNEL */
          0x00                                   /* MIN_DAQ */
          OPTIMISATION_TYPE_DEFAULT              /* OPTIMISATION_TYPE */
          ADDRESS_EXTENSION_FREE                  /* ADDRESS_EXTENSION */
          IDENTIFICATION_FIELD_TYPE_ABSOLUTE     /* IDENTIFICATION_FIELD */
          GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE    /* GRANULARITY_ODT_ENTRY_SIZE_DAQ */
          0x08                                   /* MAX_ODT_ENTRY_SIZE_DAQ */
          NO_OVERLOAD_INDICATION
          PRESCALER_SUPPORTED
          
          /begin TIMESTAMP_SUPPORTED
            1									/* TIMESTAMP_TICKS */
            SIZE_WORD							/* TIMESTAMP_SIZE */
            UNIT_1MS							/* TIMESTAMP_UNIT */
          /end TIMESTAMP_SUPPORTED
          
          /begin DAQ_LIST
            0									/* DAQ_LIST_NUMBER */
            DAQ_LIST_TYPE DAQ					/* DIRECTION */
            MAX_ODT 16							/* MAX_ODT */
            MAX_ODT_ENTRIES 7					/* MAX_ODT_ENTRIES */
            FIRST_PID  0						/* FIRST_PID for this DAQ_LIST */
            EVENT_FIXED  0						/* this DAQ_LIST always in this event */
          /end DAQ_LIST		
          /begin DAQ_LIST
            1									/* DAQ_LIST_NUMBER */
            DAQ_LIST_TYPE DAQ					/* DIRECTION */
            MAX_ODT 16							/* MAX_ODT */
            MAX_ODT_ENTRIES 7					/* MAX_ODT_ENTRIES */
            FIRST_PID  16						/* FIRST_PID for this DAQ_LIST */
            EVENT_FIXED  1						/* this DAQ_LIST always in this event */
          /end DAQ_LIST
          /begin DAQ_LIST
            2									/* DAQ_LIST_NUMBER */
            DAQ_LIST_TYPE DAQ					/* DIRECTION */
            MAX_ODT 16							/* MAX_ODT */
            MAX_ODT_ENTRIES 7					/* MAX_ODT_ENTRIES */
            FIRST_PID  32 						/* FIRST_PID for this DAQ_LIST */
            EVENT_FIXED  2						/* this DAQ_LIST always in this event */
          /end DAQ_LIST
          
          /begin EVENT
            "10ms"						/* EVENT_CHANNEL_NAME */
            "10ms"						/* EVENT_CHANNEL_SHORT_NAME */
            0						/* EVENT_CHANNEL_NUMBER */
            DAQ_STIM				/* EVENT_CHANNEL_TYPE */
            0xff					/* MAX_DAQ_LIST */
            10						/* TIME_CYCLE */
            6				/* TIMESTAMP_UNIT_1MS */
            0						/* PRIORITY */
          /end EVENT
          /begin EVENT
            "20ms"						/* EVENT_CHANNEL_NAME */
            "20ms"						/* EVENT_CHANNEL_SHORT_NAME */
            1						/* EVENT_CHANNEL_NUMBER */
            DAQ_STIM				/* EVENT_CHANNEL_TYPE */
            0xff					/* MAX_DAQ_LIST */
            20						/* TIME_CYCLE */
            6				/* TIMESTAMP_UNIT_1MS */
            0						/* PRIORITY */
          /end EVENT
          /begin EVENT
            "100ms"						/* EVENT_CHANNEL_NAME */
            "100ms"						/* EVENT_CHANNEL_SHORT_NAME */
            2						/* EVENT_CHANNEL_NUMBER */
            DAQ_STIM				/* EVENT_CHANNEL_TYPE */
            0xff					/* MAX_DAQ_LIST */
            10						/* TIME_CYCLE */
            7				/* TIMESTAMP_UNIT_1MS */
            0						/* PRIORITY */
          /end EVENT
        /end DAQ
        
        /begin PAG
          0x02						/* MAX_SEGMENTS */
          FREEZE_SUPPORTED
        /end PAG
        
        /begin PGM
          PGM_MODE_ABSOLUTE
          3								/* MAX_SECTORS */
          0x08							/* MAX_CTO_PGM */
          
          /begin SECTOR
            "sector 0"					/* SECTOR_NAME */
            0							/* SECTOR_NUM */
            0x0							/* SECTOR_ADDR */
            0x1000						/* SECTOR_LENGTH */
            2							/* CLEAR_SEQ_NUMBER */
            2							/* PROGRAM_SEQ_NUMBER */
            0							/* PROGRAM_METHOD = sequential programming */
          /end SECTOR        
          /begin SECTOR
            "sector 1"					/* SECTOR_NAME */
            1							/* SECTOR_NUM */
            0x1000						/* SECTOR_ADDR */
            0x2000						/* SECTOR_LENGTH */
            1							/* CLEAR_SEQ_NUMBER */
            1							/* PROGRAM_SEQ_NUMBER */
            0							/* PROGRAM_METHOD = sequential programming */
          /end SECTOR        
          /begin SECTOR
            "sector 2"					/* SECTOR_NAME */
            2							/* SECTOR_NUM */
            0x3000						/* SECTOR_ADDR */
            0x3000						/* SECTOR_LENGTH */
            0							/* CLEAR_SEQ_NUMBER */
            0							/* PROGRAM_SEQ_NUMBER */
            0							/* PROGRAM_METHOD = sequential programming */
          /end SECTOR
          
          COMMUNICATION_MODE_SUPPORTED
          BLOCK
          SLAVE
          MASTER
          0xff					/* MAX_BS_PGM */
          100					/* MIN_ST_PGM */
        /end PGM
        
        /begin XCP_ON_CAN
          0x0100                     /* XCP on CAN version */
          CAN_ID_MASTER 0x0667       /* CMD/STIM */
          CAN_ID_SLAVE 0x07E1        /* RES/ERR/EV/SERV */
          BAUDRATE 500000            /* BAUDRATE */
          SAMPLE_POINT 75            /* SAMPLE POINT */
          SAMPLE_RATE SINGLE         /* SAMPLE RATE */
          BTL_CYCLES  0              /* BTL CYCLES */
          SJW 2                      /* SJW */
          SYNC_EDGE SINGLE           /* SYNC EDGE */
          /begin  DAQ_LIST_CAN_ID
            0 
            FIXED 
            0x630
          /end  DAQ_LIST_CAN_ID
          /begin  DAQ_LIST_CAN_ID
            1 
            FIXED 
            0x632
          /end  DAQ_LIST_CAN_ID
          /begin  DAQ_LIST_CAN_ID
            2 
            FIXED 0x633
          /end  DAQ_LIST_CAN_ID
        /end XCP_ON_CAN
        
        /*    /end IF_DATA  */
        /*    /begin IF_DATA CANAPE_ADDRESS_UPDATE	*/
        /*    /end IF_DATA	*/
        
        /begin MOD_PAR "MOD PAR Comment Goes Here"
          VERSION "V0.1"  
          ADDR_EPK 0x0 
          EPK ""  
          SUPPLIER "FVT"  
          CUSTOMER "FVT internal + Demosample"  
          CUSTOMER_NO "NONE Demo"  
          USER "ETAS-PGA/EAP - Dm"
          PHONE_NO "0"  
          ECU "S32G274A / CAN "
          CPU_TYPE "S32G274A"
          NO_OF_INTERFACES 1 
          /* **************************************************************************************** */
          
          /*****************************************************************************************/
          /* CODE (ROM)                                                                  */
          /*****************************************************************************************/
          /begin MEMORY_SEGMENT 
            APP_CODE          /* name */
            ""                /* long identifier */
            CODE              /* PrgType */
            FLASH             /* Memory Type */
            INTERN            /* Attribute */
            0x34200000        /* Address */
            0x00080000        /* Size */
            -1 -1 -1 -1 -1    /* no mirrored segments */
            /begin IF_DATA XCP
              /begin SEGMENT
                0x00                         /* segment logical number */
                0x01                         /* number of pages */
                0x00                         /* address extension */
                0x00                         /* Compression method */
                0x00                         /* Encryption method */
                /begin CHECKSUM    
                  XCP_ADD_14                /* checksum through external function */
                  MAX_BLOCK_SIZE 0x00000800 /* maximum block size */
                /end CHECKSUM      
                /begin PAGE
                  0x00                           /* page number */
                  ECU_ACCESS_WITH_XCP_ONLY
                  XCP_READ_ACCESS_WITH_ECU_ONLY
                  XCP_WRITE_ACCESS_NOT_ALLOWED
                /end PAGE
              /end SEGMENT
            /end IF_DATA
          /end MEMORY_SEGMENT
          /begin MEMORY_SEGMENT 
            APP_CODE          /* name */
            ""                /* long identifier */
            RESERVED          /* PrgType */
            RAM               /* Memory Type */
            INTERN            /* Attribute */
            0x34500000        /* Address */
            0x00100000        /* Size */
            -1 -1 -1 -1 -1    /* no mirrored segments */
          /end MEMORY_SEGMENT
          /*****************************************************************************************/
          /* REFERENCE PAGE (ROM)                                                */
          /*****************************************************************************************/
          /begin MEMORY_SEGMENT 
            APP_CALIBDATA         /* name */ 
            ""                    /* long identifier */
            DATA                  /* PrgType */
            FLASH                 /* Memory Type */
            INTERN                /* Attribute */
            0x34420000            /* REFERENCE PAGE START ADDRESS */
            0x00020000            /* REFERENCE PAGE SIZE */
            -1 -1 -1 -1 -1
            /begin IF_DATA XCP
              /begin SEGMENT
                0x01            /* segment logical number */
                0x01            /* number of pages */
                0x00            /* address extension */
                0x00            /* Compression method */
                0x00            /* Encryption method */
                /begin CHECKSUM    
                  XCP_ADD_14                /* checksum through external function */
                  MAX_BLOCK_SIZE 0x00000800 /* maximum block size */
                /end CHECKSUM    
                /begin PAGE
                  0x00         /* page number */
                  ECU_ACCESS_WITH_XCP_ONLY
                  XCP_READ_ACCESS_WITH_ECU_ONLY
                  XCP_WRITE_ACCESS_WITH_ECU_ONLY
                  INIT_SEGMENT 0x00
                /end PAGE
                /begin ADDRESS_MAPPING  
                  0x34420000          /* from */
                  0x34420000          /* to */      
                  0x00020000          /* length */
                /end ADDRESS_MAPPING	
              /end SEGMENT
            /end IF_DATA
          /end MEMORY_SEGMENT
          /*****************************************************************************************/
          /* VARIABLE PAGE (RAM)                                                */
          /*****************************************************************************************/
          /begin MEMORY_SEGMENT
            DATA_BSS              /* name */ 
            ""                    /* long identifier */
            RESERVED              /* PrgType */
            RAM                   /* Memory Type */
            INTERN                /* Attribute */
            0x34280000            /* REFERENCE PAGE START ADDRESS */
            0x00180000            /* REFERENCE PAGE SIZE */
            -1 -1 -1 -1 -1
          /end MEMORY_SEGMENT
          
          /begin MEMORY_SEGMENT 
            RAM_CORE1_CALIBDATA
            ""
            VARIABLES	/* CALIBRATION_VARIABLES */
            RAM
            INTERN
            0x34400000                 /* VARIABLE PAGE START ADDRESS */
            0x00020000                 /* VARIABLE PAGE SIZE */
            -1 -1 -1 -1 -1
          /end MEMORY_SEGMENT
          
        /end MOD_PAR
        
        
        /begin RECORD_LAYOUT Scalar_BOOLEAN
          FNC_VALUES  1 UBYTE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Scalar_UBYTE
          FNC_VALUES  1 UBYTE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Scalar_BYTE
          FNC_VALUES  1 SBYTE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Scalar_UWORD
          FNC_VALUES  1 UWORD COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Scalar_SWORD
          FNC_VALUES 1 SWORD COLUMN_DIR DIRECT
        /end RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Scalar_ULONG
          FNC_VALUES  1 ULONG COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Scalar_LONG
          FNC_VALUES  1 SLONG COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Scalar_FLOAT32_IEEE
          FNC_VALUES  1 FLOAT32_IEEE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Scalar_FLOAT64_IEEE
          FNC_VALUES  1 FLOAT64_IEEE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        
        /begin RECORD_LAYOUT Lookup1D_BOOLEAN
          FNC_VALUES  1 UBYTE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_X_BOOLEAN
          AXIS_PTS_X  1 UBYTE INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_BYTE
          FNC_VALUES  1 SBYTE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_X_BYTE
          AXIS_PTS_X  1 SBYTE INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_UBYTE
          FNC_VALUES  1 UBYTE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_X_UBYTE
          AXIS_PTS_X  1 UBYTE INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_UWORD
          FNC_VALUES  1 UWORD COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_X_UWORD
          AXIS_PTS_X  1 UWORD INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_WORD
          FNC_VALUES  1 SWORD COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_X_WORD
          AXIS_PTS_X  1 SWORD INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_ULONG
          FNC_VALUES  1 ULONG COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_X_ULONG
          AXIS_PTS_X  1 ULONG INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_SLONG
          FNC_VALUES  1 SLONG COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_X_LONG
          AXIS_PTS_X  1 SLONG INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_FLOAT32_IEEE
          FNC_VALUES  1 FLOAT32_IEEE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_X_FLOAT32_IEEE
          AXIS_PTS_X  1 FLOAT32_IEEE INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_FLOAT64_IEEE
          FNC_VALUES  1 FLOAT64_IEEE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup1D_X_FLOAT64_IEEE
          AXIS_PTS_X  1 FLOAT64_IEEE INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_BOOLEAN
          FNC_VALUES  1 UBYTE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_X_BOOLEAN
          AXIS_PTS_X  1 UBYTE INDEX_INCR DIRECT
        /end   RECORD_LAYOUT    
        
        /begin RECORD_LAYOUT Lookup2D_UBYTE
          FNC_VALUES  1 UBYTE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_X_UBYTE
          AXIS_PTS_X  1 UBYTE INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_BYTE
          FNC_VALUES  1 SBYTE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_X_BYTE
          AXIS_PTS_X  1 SBYTE INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_UWORD
          FNC_VALUES  1 UWORD COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_X_UWORD
          AXIS_PTS_X  1 UWORD INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_WORD
          FNC_VALUES  1 SWORD COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_X_WORD
          AXIS_PTS_X  1 SWORD INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_ULONG
          FNC_VALUES  1 ULONG COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_X_ULONG
          AXIS_PTS_X  1 ULONG INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_LONG
          FNC_VALUES  1 SLONG COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_X_LONG
          AXIS_PTS_X  1 SLONG INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_FLOAT32_IEEE
          FNC_VALUES  1 FLOAT32_IEEE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_X_FLOAT32_IEEE
          AXIS_PTS_X 1 FLOAT32_IEEE INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_FLOAT64_IEEE
          FNC_VALUES  1  FLOAT64_IEEE COLUMN_DIR DIRECT
        /end   RECORD_LAYOUT
        
        /begin RECORD_LAYOUT Lookup2D_X_FLOAT64_IEEE
          AXIS_PTS_X 1 FLOAT64_IEEE INDEX_INCR DIRECT
        /end   RECORD_LAYOUT
        
        
        /begin CHARACTERISTIC
          /* Name                   */      KHAL_CAN1TxReq_flg  
          /* Long Identifier        */      ""
          /* Type                   */      VALUE 
          /* ECU Address            */      0x0000 /* @ECU_Address@KHAL_CAN1TxReq_flg@ */ 
          /* Record Layout          */      Scalar_BOOLEAN 
          /* Maximum Difference     */      0 
          /* Conversion Method      */      SWC_HALOUT_type_CM_boolean_flg 
          /* Lower Limit            */      0.0 
          /* Upper Limit            */      1.0
        /end CHARACTERISTIC
        
        
        /begin CHARACTERISTIC
          /* Name                   */      KHAL_CAN2TxReq_flg  
          /* Long Identifier        */      ""
          /* Type                   */      VALUE 
          /* ECU Address            */      0x0000 /* @ECU_Address@KHAL_CAN2TxReq_flg@ */ 
          /* Record Layout          */      Scalar_BOOLEAN 
          /* Maximum Difference     */      0 
          /* Conversion Method      */      SWC_HALOUT_type_CM_boolean_flg 
          /* Lower Limit            */      0.0 
          /* Upper Limit            */      1.0
        /end CHARACTERISTIC
        
        
        /begin CHARACTERISTIC
          /* Name                   */      KHAL_CAN3TxReq_flg  
          /* Long Identifier        */      ""
          /* Type                   */      VALUE 
          /* ECU Address            */      0x0000 /* @ECU_Address@KHAL_CAN3TxReq_flg@ */ 
          /* Record Layout          */      Scalar_BOOLEAN 
          /* Maximum Difference     */      0 
          /* Conversion Method      */      SWC_HALOUT_type_CM_boolean_flg 
          /* Lower Limit            */      0.0 
          /* Upper Limit            */      1.0
        /end CHARACTERISTIC
        
        
        /begin CHARACTERISTIC
          /* Name                   */      KHAL_CAN4TxReq_flg  
          /* Long Identifier        */      ""
          /* Type                   */      VALUE 
          /* ECU Address            */      0x0000 /* @ECU_Address@KHAL_CAN4TxReq_flg@ */ 
          /* Record Layout          */      Scalar_BOOLEAN 
          /* Maximum Difference     */      0 
          /* Conversion Method      */      SWC_HALOUT_type_CM_boolean_flg 
          /* Lower Limit            */      0.0 
          /* Upper Limit            */      1.0
        /end CHARACTERISTIC
        
        
        /begin CHARACTERISTIC
          /* Name                   */      KHAL_CAN5TxReq_flg  
          /* Long Identifier        */      ""
          /* Type                   */      VALUE 
          /* ECU Address            */      0x0000 /* @ECU_Address@KHAL_CAN5TxReq_flg@ */ 
          /* Record Layout          */      Scalar_BOOLEAN 
          /* Maximum Difference     */      0 
          /* Conversion Method      */      SWC_HALOUT_type_CM_boolean_flg 
          /* Lower Limit            */      0.0 
          /* Upper Limit            */      1.0
        /end CHARACTERISTIC
        
        
        /begin CHARACTERISTIC
          /* Name                   */      KHAL_CAN6TxReq_flg  
          /* Long Identifier        */      ""
          /* Type                   */      VALUE 
          /* ECU Address            */      0x0000 /* @ECU_Address@KHAL_CAN6TxReq_flg@ */ 
          /* Record Layout          */      Scalar_BOOLEAN 
          /* Maximum Difference     */      0 
          /* Conversion Method      */      SWC_HALOUT_type_CM_boolean_flg 
          /* Lower Limit            */      0.0 
          /* Upper Limit            */      1.0
        /end CHARACTERISTIC
        
        
        /begin CHARACTERISTIC
          /* Name                   */      KHAL_CAN7TxReq_flg  
          /* Long Identifier        */      ""
          /* Type                   */      VALUE 
          /* ECU Address            */      0x0000 /* @ECU_Address@KHAL_CAN7TxReq_flg@ */ 
          /* Record Layout          */      Scalar_BOOLEAN 
          /* Maximum Difference     */      0 
          /* Conversion Method      */      SWC_HALOUT_type_CM_boolean_flg 
          /* Lower Limit            */      0.0 
          /* Upper Limit            */      1.0
        /end CHARACTERISTIC
        
        
        /begin COMPU_METHOD
          /* Name of CompuMethod    */      SWC_HALOUT_type_CM_boolean_flg
          /* Long identifier        */      "Q = V"
          /* Conversion Type        */      RAT_FUNC
          /* Format                 */      "%1.0"
          /* Units                  */      "flg"
          /* Coefficients           */      COEFFS 0 1 0 0 0 1
        /end COMPU_METHOD
        
        /begin GROUP
          /* Name                   */       SWC_HALOUT_type
          /* Long identifier        */       "SWC_HALOUT_type"
          /* Root                    */       ROOT
          /begin SUB_GROUP
            Root_run_SWC_HALOUT_Tx_5ms_sys
          /end SUB_GROUP
        /end GROUP
        
        /begin GROUP
          /* Name                   */       Root_run_SWC_HALOUT_Tx_5ms_sys
          /* Long identifier        */       "SWC_HALOUT_type/run_SWC_HALOUT_Tx_5ms_sys"
          /begin SUB_GROUP
            S17_HAL_OUT
          /end SUB_GROUP
        /end GROUP
        
        /begin GROUP
          /* Name                   */       S17_HAL_OUT
          /* Long identifier        */       "SWC_HALOUT_type/run_SWC_HALOUT_Tx_5ms_sys/HAL_OUT"
          /begin REF_CHARACTERISTIC
            KHAL_CAN1TxReq_flg
            KHAL_CAN2TxReq_flg
            KHAL_CAN3TxReq_flg
            KHAL_CAN4TxReq_flg
            KHAL_CAN5TxReq_flg
            KHAL_CAN6TxReq_flg
            KHAL_CAN7TxReq_flg
          /end REF_CHARACTERISTIC
        /end GROUP
        
        
      /end MODULE
      
      
    /end PROJECT
    /* (add any file trailer comments here) */
    /* EOF SWC_HALOUT_type.a2l */
